datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL")
}
 
generator client {
  provider = "prisma-client-js"
}
 
model User {
  id            String          @id @default(auto()) @map("_id") @db.ObjectId
  name          String
  email         String         @unique
  password      String
  emailVerified DateTime?
  image         String?         @default("https://upload.wikimedia.org/wikipedia/commons/thumb/2/2c/Default_pfp.svg/2048px-Default_pfp.svg.png")
  accounts      Account[]
  sessions      Session[]
  // Optional for WebAuthn support
  Authenticator Authenticator[]

  collections Collection[]

  classes Classes[]
 
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// Made to keep all the flashcard data in one place. For example one collection can keep data for multiple flashcards. One collection can have as many flashcards as you want. The collection has to have a relation with the user.
model Collection {
  id String @id @default(auto()) @map("_id") @db.ObjectId
  title String
  description String?

  likes String[] @default([])
  seen String[] @default([])

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId String @db.ObjectId

  flashcards Flashcard[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Flashcard {
  id String @id @default(auto()) @map("_id") @db.ObjectId
  question String
  answer String
  hint String?

  collection Collection @relation(fields: [collectionId], references: [id], onDelete: Cascade)
  collectionId String @db.ObjectId

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// Each class will have a creator which will be the user who created the class. The class can have many users who are enrolled in the class. 
model Classes {
  id String @id @default(auto()) @map("_id") @db.ObjectId
  title String
  description String?

  creator User @relation(fields: [creatorId], references: [id], onDelete: Cascade)
  creatorId String @db.ObjectId

  // users User[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// model Conversation {
//   id String @id @default(auto()) @map("_id") @db.ObjectId

//   messagesIds String[] @db.ObjectId
//   messages Message[]

//   senderIds String @db.ObjectId
//   users  User[]  @relation(fields: [senderIds], references: [id])

//   createdAt DateTime @default(now())
//   updatedAt DateTime @updatedAt
// }

// model Message {
//     id String @id @default(auto()) @map("_id") @db.ObjectId
//     body String?
//     image String?
//     createdAt DateTime @default(now())

//     conversationId String @db.ObjectId
//     conversation Conversation  @relation(fields: [conversationId], references: [id], onDelete: Cascade)

//     senderId String @db.ObjectId
//     sender User @relation(fields: [senderId], references: [id], onDelete: Cascade)
// }
 
model Account {
  id                String  @id @default(auto()) @map("_id") @db.ObjectId
  userId            String  @db.ObjectId
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.String
  access_token      String? @db.String
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.String
  session_state     String?
 
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
 
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
 
  @@unique([provider, providerAccountId])
}
 
model Session {
  id           String   @id @default(auto()) @map("_id") @db.ObjectId
  sessionToken String   @unique
  userId       String   @db.ObjectId
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
 
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}
 
model VerificationToken {
  id         String   @id @default(auto()) @map("_id") @db.ObjectId
  identifier String
  token      String
  expires    DateTime
 
  @@unique([identifier, token])
}
 
model Authenticator {
  credentialID         String  @id @map("_id")
  userId               String  @db.ObjectId
  providerAccountId    String
  credentialPublicKey  String
  counter              Int
  credentialDeviceType String
  credentialBackedUp   Boolean
  transports           String?
 
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
 
  @@unique([userId, credentialID])
}